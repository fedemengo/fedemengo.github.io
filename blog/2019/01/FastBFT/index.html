<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Scalable Byzantine Consensus via Hardware-assisted Secrete Sharing | fedemengo</title>
    <meta name="author" content="fedemengo  ">
    <meta name="description" content="Fastest and most scalable BFT protocol">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="/assets/img/code.png">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://fedemengo.github.io/blog/2019/01/FastBFT/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>

    <!-- Online 3D Viewer -->
    <script src="/assets/js/o3dv/o3dv.min.js"></script>
    <script>
        OV.SetExternalLibLocation ('libs'); // tell the engine where to find the libs folder
        OV.Init3DViewerElements (); // init all viewers on the page
    </script>
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "Scalable Byzantine Consensus via Hardware-assisted Secrete Sharing",
      "description": "Fastest and most scalable BFT protocol",
      "published": "January 22, 2019",
      "authors": [
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">fedemengo</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>Scalable Byzantine Consensus via Hardware-assisted Secrete Sharing</h1>
        <p>Fastest and most scalable BFT protocol</p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        

        <p><a href="https://arxiv.org/pdf/1612.04997v1.pdf" rel="external nofollow noopener" target="_blank">Scalable Byzantine Consensus via Hardware-assisted Secrete Sharing</a></p>

<p>The author of this paper described <strong>FastBFT</strong> a new BFT protocols, highly scalable that achieve better performances than any other BFT protocols. The protocol was designed by studying the weakness of other popular protocols<!--more--> such as <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" rel="external nofollow noopener" target="_blank">PBFT</a>, <a href="https://www.cs.utexas.edu/~lorenzo/papers/kotla07Zyzzyva.pdf" rel="external nofollow noopener" target="_blank">Zyzzyva</a>, <a href="http://web.cs.ucdavis.edu/~peisert/research/2014-OPODIS-BChain.pdf" rel="external nofollow noopener" target="_blank">BChain</a> and <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.513.2850&amp;rep=rep1&amp;type=pdf" rel="external nofollow noopener" target="_blank">MiniBFT</a> to improve upon them. There are several components that characterize the paper.</p>

<p>The protocol is an <strong>hybrid</strong> protocol that require hardware assistance (so it only require $2f+1$ nodes in the network) based on a optimistic paradigm (requests are executed before reaching the agreement) that require only $f+1$ active replica to agree and execute a transaction while the other $f$ passive replicas are updates by the network.</p>

<h2 id="message-aggregation">Message aggregation</h2>

<p>To reach the agreement in BFT protocols, $O(n^2)$ messages are required since every replica $S_i$ multicast a commit message (in the general case) to all other active replicas in the network. The $O(n^2)$ message complexity represent the main bottleneck in PBFT.</p>

<p>During the commit phase of the protocol, each replica sends a commit message directly to the primary instead of multicasting the message to the network. To reduce the overhead of message aggregation the authors use <strong>secret sharing</strong> instead of a classical multisignatures approach.</p>

<p>To implement secret sharing, an additional phase of <code class="language-plaintext highlighter-rouge">pre-processing</code> it’s necessary to set up the “secret shares”.</p>

<h3 id="pre-processing">Pre-processing</h3>

<p>In this phase the primary/leader $S_p$ generates a set of random secrets and publish a cryptographic hash of each of them (each secret will be bound to a single requests in the <code class="language-plaintext highlighter-rouge">prepare</code> phase). Then $S_p$ creates $f+1$ shares (and its hash as well) of the message and send one share to each active replica.</p>

<p>In the commit phase, every replica will reveals its share to the primary that will reconstruct the secret (if it receives enough valid shares). The secret is the multicasted by $S_p$ to all the replicas that can verify it (they verify that the hash previously bound to the request is actually correct).</p>

<p>To ensure that $S_p$ doesn’t impersonate any other $S_i$ the generation of secrete, hash, shares and binding happens inside the <strong>TEE</strong> (Trusted Execution Environment) and each secret is bound to a monotonic counter (as well as a single request).</p>

<h2 id="communication-topology">Communication topology</h2>

<p>To further improve the exchange of messages, the network is organized (by the primary) in a balance tree structure rooted at $S_p$. Instead of receiving all $n$ messages from the replicas, the primary take advantage of the tree topology that will allow it to receive a constant number of messages (equal to the branching factor of each node, in the simplest case $n = 2$).</p>

<h3 id="failure-detection">Failure detection</h3>

<p>Crashes are detected by timeout while Byzantine faults are detected by verifying shares: when a node $S_i$ receive a message from one of its children its check whether the aggregate shares is valid. If the shares received are wrong, the node will directly send a <code class="language-plaintext highlighter-rouge">SUSPECT</code> message to its parent (hence aborting the transaction), the message will eventually reach the primary that will be in charge of rearranging the network by putting the suspected faulty node in one of the leaves.</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/"></d-bibliography>
</div>

    <!-- Footer -->    <footer class="sticky-bottom mt-5">
      <div class="container">
        © Copyright 2023 fedemengo  . Last updated: April 28, 2023.
      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
